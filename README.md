#	Series Scoring SQLite Database

##	Introduction

The purpose of this repository is to share the SQLite code I have developed for tracking scores given during [The Landing Party](https://www.youtube.com/@gnolan12/streams) on Graham Nolan's YouTube channel.
In this weekly podcast the hosts are reviewing *Star Trek* episode-by-episode, following the original production order.
Believing it would be a fair way to practice and develop my SQL skills, I decided to build a database of their scores.

Over time I have developed various features for the database, such as Views to calculate various summary values, but also to group episodes by each host's scores.
All of this code has been hand-written, and while this works, it does get very tedious and prone to errors, so I have decided to rebuild the SQL code so it can be generated by the database itself.
This is especially useful as the generated code will adapt to new hosts being added to a series table, so only a simple copy-paste process is necessary to update the views and include the host.

For my own ease, I am going to assume some level of SQL(lite) understanding as I go over the contents of the repository and the set up process.

### Software used:
- [DB Browser for SQLite](https://sqlitebrowser.org/)

###	Video Example:
- [Series Scoring Database Set-up and Overview](https://youtu.be/ruXL31YjFBw)

---

## Step 1: Initial Database Configuration

To get started you can either use the **Series Score - Blank.db** file or start a fresh database and reference/use the code in **Series Scoring - Code.sql**.
The lone advantage to starting with the *DB* file is it already has two Views on it, but these are created by executing code in the *SQL* file, so it is only a single step saved.

The first step I recommend is creating the tables for the database.
The **Example Code.sql** file contains example code for this process, based on the three Stargate series.
There is also table creation code at the top of **Series Scoring - Code.sql** if you would prefer, and you can "Create Table" button in DB Browser as well.
As the specific formatting of these tables is important though, I would suggest using the code to create them than the button.

The database is designed to work with multiple series in a franchise, with each series receiving its own table.
(If there are any related films you can create a table for them.)
Because of how alphabetical sorting works in SQL(ite), I prefer to start the table names with `@` to ensure they are near the top.

```
CREATE TABLE "@series" (
	"Episode-Air"	TEXT,
	"Title"	TEXT,
	"hostA"	NUMERIC,
	"hostB"	NUMERIC,
	"hostC"	NUMERIC,
	...
	"Link"	TEXT,
	"IMDB_Rating"	NUMERIC
)
```

With the exception of the "Link" column, all of these are required.
The "IMDB_Rating" column I added because I like the idea of being able to compare the host scores against this larger-sample average.

The "Episode-Air" column expects a pattern following the `S##E##` format, or similar.
The key thing is the season number to be identified starting with an `S`.

Naturally the "hostA", "hostB", etc. columns should be renamed as appropriate, and you can add more of them if you wish.
It is crucial they remain `NUMERIC` columns however, as this is used to identify them.

In addition to the series tables, the "_Order_Series" table to record their sorting order, readable name, and abbreviation is also required.

```
CREATE TABLE "_Order_Series" (
	"sort"	INTEGER UNIQUE,
	"name"	TEXT UNIQUE,
	"abbr"	TEXT,
	PRIMARY KEY("sort" AUTOINCREMENT)
);
```

None of the names here can be changed.

##	Step 2: Data Entry

As it may seem a bit odd, I will start with the "_Order_Series" table, as it is the best way to fully explain its purpose.

It contains three columns, with the "sort" column being one the database itself will fill out, as it autoincrements.

The "name" column is for the readable name of the TV series.
Using the Stargate series as the example:
- Stargate SG1
- Stargate Atlantis
- Stargate Universe

The "abbr" column then holds an abbreviation for the series, which is typically three characters.
(There is some code that expects it to be three characters, but it is not critical.)
Continuing with the Stargate series:
- SG1
- SGA
- SGU

You can enter this data manually into the table, or you can build and run an `INSERT` command to do so.

```
INSERT INTO "_Order_Series" ("name", "abbr") VALUES
('Stargate SG1', 'SG1'),
('Stargate Atlantis', 'SGA'),
('Stargate Universe', 'SGU');
```

Because the "sort" column autoincrements, we do not need to explicitly give it any values here.
If you find you wish to reorder the series, edit the "name" and "abbr" columns rather than touch the "sort" column.

Entering data into the series tables can be a little tedious, which is why I strongly recommend using `INSERT` commands when first building up the table.
My reasoning for this recommendation is that (outside of the examples here) it makes sense to enter every episode of a series into the table at the start, and then add in host scores as they come up.

Here is an example to add the first few episodes of *Stargate SG1* to its table:

```
INSERT INTO "@Stargate_SG1" ("Episode-Air", "Title") VALUES
('S01E01-E02', 'Children of the Gods'),
('S01E03', 'The Enemy Within'),
('S01E04', 'Emancipation');
```

If you do already have scores for it, or are just making them up as I did for example data, the command can look like this:

```
INSERT INTO "@Stargate_SG1" VALUES
('S01E01-E02', 'Children of the Gods', '8', '7.5', '6', '8', NULL, '7.8'),
('S01E03', 'The Enemy Within', '8', '6.5', '7.5', '9', NULL, '7.6'),
('S01E04', 'Emancipation', '8', '7', '9', '7', NULL, '5.9');
```

Because I am giving a value to each column, and in the same order as the table, I do not need to name them before `VALUES`.
(The "Link" column is `NULL` because this is bogus example data and so there is no link to a podcast episode.)

##	Step 3: View Creation

Despite the hundreds of lines of code involved, this is actually the easiest step.
It is also unnecessary if you started with the *DB* file as the required `__RUN` and optional `__RUN_Ranks-Season` and `__RUN_Ranks-Specific` views are already in it.
Unlike the other views we will be making, these two are not especially dependent on anything else in the database.
`__RUN_Ranks-Season` is where the abbreviations being just three characters is important though, but being optional you can just skip/delete the view if you wish.

To create the `__RUN` view simply open the **Series Score - Code.sql** and select from line 23, which reads `DROP VIEW IF EXISTS '__RUN';`, to either line 179, which reads `ORDER BY sort );`, or go to the end of the file.
The code after line 179 is for creating the other views and it can all be executed at the same time.

###	Step 3.1: __RUN Execution

This too is a very simple step as you need only open the `__RUN` view, select everything in the **OUT** column, and execute it.

That is it.

That column contains all of the code to create the various views for based on the tables in the database.

- `Score-Averages`
	- This view provides the average (mean), standard deviation, count of hosts, IMDB score, and the difference between the IMDB score and average for each episode.
- `@_Summary`
	- Derived from `Score-Averages`, this provides a readble string reporting the average and standard deviation for each episode with a score, but with the latest episode at the top.
- Ranks per Series or `Ranks-***`
	- These views provide per-host information, including their average score and number of episodes they have provided a score for at the top, then lists of each episode grouped by each score. For example, if a host gives three episodes the same score, these episodes will listed and a 3 will be placed in the appropriate "Count" column.

###	Step 3.2: __RUN_Ranks-Season

Unfortunately one thing I have not been able to find a way to completely automate is the creation of the `Ranks-***` views that filter by the season.
My solution then is this `__RUN_Ranks-Season` view that takes the code created by `__RUN` and uses the `REPLACE` command to give example code.

If you want views that give the rank information, you will have to manually compose those queries yourself, but this should help.

This view takes the code for generating the `Ranks-***` views and replaces part of it to apply per-season filtering.
This means the resulting code will create a view that only shows the data for that one season, but with the appropriate use of the `JOIN` command you can combine this with the original `Ranks-***` code to have it all in one view.

###	Step 3.3: _Ranks-Specific

This view generates the code to select the score and host columns in the `Ranks-***` views.
The idea being you can then copy this code and edit it, such as removing specific hosts, so you can select just those you are interested in.
If you have created a ranks view that includes per-season columns, then this can also be used to easily select just those columns for a single season or all the columns for a single host across the series and seasons.
Really it is just providing you with code so you do not need to write it out by hand; a labor-saving device.

##	Stream_Notes

I have added support for a "_Stream_Notes" table that relates to the other tables via the "Link" column, though in this table it is "Stream_Link".
The "Stream_Link" column must only allow unique values.
The purpose is to record any notes concerning each stream, such as if scores for past episodes are changed.

```
CREATE TABLE "Stream_Notes" (
	"Stream_Date"	TEXT,
	"Stream_Link"	TEXT UNIQUE,
	"Notes"	TEXT,
	...
);
```

The "_Stream_Notes_Update" view provides code that will add any missing links to this table, based on what is in the @series tables.
This is why the "Stream_Link" column can only allow unique values, as that allows a constraint that prevents links from being duplicated.

---

#	R-Shiny Visualizer ("app_Series-Scoring.r")

While the database is great for tracking scores and some of the calculations and grouping, there are better options for fully visualizing the data.
That that end, I have built such a visualizer using R-Shiny, which is free and open source (both R and the packages used).

To use this, first install R that can be found here: [R-Project.org](https://www.r-project.org/).
Next, place the "app_Series-Scoring.r" in the same folder as the database, as this is where it looks for the file.
Open the R GUI and copy the contents of the R script into it, or at least its beginning with the `if (!require(...` lines as these tell R to install the necessary packages.
There will likely be pop-ups to confirms R is allowed to go online and which repository it should download the packages from.

When you run the script it will create a front-end webpage to present the information and a back-end in which R does all of the data processing.
The front-end will either be opened directly into your web browser or a URL will be shown to you for this front-end.
The URL will resemble `127.0.0.1:1234`.
This tells the browser to look on the local machine (`127.0.0.1`) at a specific port (`1234`).
The port will change whenever the script is run.

The first steps to using the front-end are to select the database file to load from the drop down on at the top of the side bar on the left side of the page, pressing the button to load it, and then selecting the desired table in the list below it, pressing the button to load it as well.
At this point the data will be loaded and the rest of the UI will fill out, and I would like to believe I can let you explore it on your own.

There are a couple important points about this though.
One is the visualizer expects there to be some value in the database table's "Link" column, to recognize there are scores recorded for that episode.
Not every part of the visualizer as this expectation, but some do.
Another is the visualizer supports multiple episode order columns, but expects them to include "Episode" in the name.
Ideally these columns will be named `Episode-X`, `Episode Y` or `Episode.Z` for best compatibility with the applet.
(R will replace spaces and dashes with `.` when they are in column names.)
This is for tracking the production order of the episodes and is from why I first built the database, but is optional.

The vizualer supports other, optional columns as well.
Columns that include `Rating` in the name will be excluded from calculations but can be toggled on and off for the graphs.
These are for if you want to record the rating given to an episode from some non-Host source, allowing comparisons.

Lastly, you can add arbitrary columns of data type "TEXT" that the visualizer will allow to be shown or not, but will not influence anything, like the optional `Rating` columns.
